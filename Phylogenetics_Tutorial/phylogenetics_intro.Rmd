---
title: "Phylogenetic Analysis of Doubly Uniparental Inheritance (DUI) in Bivalves"
author: "K. Garrett Evensen"
date: "5/3/2022"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction to Phylogenetics

 We are going to make a phylogenetic tree of bivalves using several different methods. The first is a maximum parsimony treeusing aligned cox1 sequences created using MUSCLE. We will create two trees using R and then two more using RAxML (maximum likelihood) and BEAST (Bayesian). Once we have learned how to make and graph phylogenetic trees, we can conduct ancestral state reconstruction of Doubly Uniparental Inheritance (DUI) in bivalves and determine if DUI is correlated with gonochorism.
 
 Before we can make a phylogenetic tree, we some sequences. There is a file called cox1.fasta. That file has cytochrome c oxidase sequences for 18 species: 16 bivalves and 2 other mollusks. Next, we need to align these sequences. I normally use MUSCLE. There are other alignment softwares that you can use though. You can use MUSCLE by downloading the software (paste link) and running it on the command line, or use an online tool (paste links) that uses MUSCLE. If you are using it on the command line, use the code pasted below:
 
 muscle3.8.31_i86darwin64 -in cox1.fasta -fastaout cox1_align.fasta
 
 Now we can make phylogenetic trees!
 
 If you don't have treeio or ggtree installed, run this code:

````{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("treeio")
BiocManager::install("ggtree")
````
 
````{r}
require(ape)
require(phangorn)
require(phytools)
require(ggtree)
require(treeio)
````
 First we will import the aligned sequences in fasta format and then convert it to a phyDat object.
 
````{r}
cox1.dna <- read.dna("cox1_align.fasta", format="fasta")
cox1.phyDat <- as.phyDat(cox1.dna)
````

# Maximum Parsimony

The first tree we will make is a maximum parsimony (MP) tree (think Occam's Razor).

````{r}
mp.tree<-pratchet(cox1.phyDat) 
mp.tree$edge.length<-runif(n=nrow(mp.tree$edge))
plot.phylo(mp.tree)
````

# Maximum Likelihood

The next method is maximum likelihood (ML). Before we can make the tree, we have to determine which is the best model for making an ML tree.

````{r}
mt.result<-modelTest(pml(mp.tree,data=cox1.phyDat)) #determine which is the best model for ML
rnd<-function(x,...) if(is.numeric(x)) round(x,...) else x
as.data.frame(lapply(mt.result,rnd,digits=2))
````

Based on these results, the GTR+G+I model is the best model for ML. In the optim.pml function, we set optGamma=TRUE and optInv=TRUE to add the G and I to the GTR model.

````{r}
obj<-pml(tree=rtree(n=length(cox1.phyDat),tip.label=names(cox1.phyDat),
                    rooted=FALSE),data=cox1.phyDat)
fit.ml <- optim.pml(obj,optEdge=TRUE,model="GTR",optGamma=TRUE, optInv=TRUE,rearrangement="NNI")
plot.phylo(midpoint.root(fit.ml$tree))
````

How does the ML tree compare to the MP tree? Are they the same?

# Bootstrapping Maximum Likelihood

To improve our confidence in the strenght of nodes, we will use bootstrapping. You can use 100, but 1000 is better. Here, we will only use 100 for the sake of computational time. For plotting, we will keep only bootstrap values greater than 50. A value of 70 is roughly equivalent to a p value of 0.05.

````{r, echo=FALSE, results='hide',fig.keep='all'}
bs = bootstrap.pml(fit.ml, bs=100, optNni=TRUE) 
plotBS(midpoint(fit.ml$tree), bs, p = 50, type="p")
````

# Maximum Likelihood with RAxML

To make a tree using RAxML (https://cme.h-its.org/exelixis/web/software/raxml/), you can use the code provided on Github, or use the code copied below:

raxmlHPC-PTHREADS-AVX -s cox1_align.fasta -f a -k -# 1000 -n cox1 -m GTRGAMMAI -p 912046 -x 14826 -T 2

This code bootstraps 1000 times and uses the GTR+G+I model. Make sure to read the vignette to understand all the possible options for RAxML. There will be five different output files. We will use the one with bipartitionsBranchLabels. You can draw the phylogenetic tree in two different ways. The first using plot.phylo in the ape package, and the second uses ggtree.

````{r}
cox1_raxml <- read.raxml('RAxML_bipartitionsBranchLabels.cox1')
````

````{r}
plot.phylo(cox1_raxml@phylo)
````

Next, we will use ggtree. This package gives us lots of different options for graphing. It works similar to ggplot. For now, we will keep it simple.

````{r}
ggtree(cox1_raxml) + xlim(0, 4) +
  geom_tiplab(align = TRUE) + 
  geom_text2(aes(label=bootstrap), hjust = 1, vjust = -0.1)
````

BEAST

Next, we are going to use BEAST2 (https://www.beast2.org) to make a Bayesian tree using the same alignment file. Make sure to read the full instructions online for proper installation. Below I've pasted quick instructions on what I did to make this tree.

Convert alignment to nexus format: http://phylogeny.lirmm.fr/phylo_cgi/data_converter.cgi

Open BEAUti, load the .nex file by clicking the plus on the bottom left of the window. Under Site Model set the substitution model to GTR. It should be JC69 by default. Then generate the BEAST .xml file by clicking file and saving the .xml file. It will defualt to 10,000,000 generations, but you can change this if you want under MCMC.

Next, open BEAST choose the .xml you just generated. I called mine cox1.xml because we are working with the cox1 gene. You can keep the Thread Pool Size set to automatic, or you can set the number of threads depending on your machine and if you are doing anything else while BEAST is running. Check Use BEAGLE library if available. Then click Run. 

Finally, open TreeAnnotator and load the .trees file. Set the burnin to be 25%. Name the output and click Run. I've named the file cox1_beast.tre. Now we can import the BEAST tree and graph it. 

````{r}
cox1_beast <- read.beast('cox1_beast.tre')
````

````{r}
ggtree(cox1_beast) + xlim(0, 3) +
  geom_tiplab(align = TRUE) + 
  geom_text2(aes(label=round(as.numeric(posterior), 2), x=branch), hjust = 0.75, vjust=0)
````

# Compare RAxML and BEAST Trees

Frequently, you will want to compare the topologies of trees made using the same alignment file, but with two different methods. We can do this using the phytools package.

````{r}
t1 <- force.ultrametric(cox1_raxml@phylo, "nnls")
t2 <- force.ultrametric(cox1_beast@phylo, "nnls")
obj2 <- cophylo(t1, t2)
plot(obj2,link.type="curved",link.lwd=4,link.lty="solid",
     link.col=make.transparent("blue",0.4),fsize=1)
````

As you can see, the topologies of the two trees are nearly the same. Are they the same as the MP tree and first ML tree we made? How are they different?

# Rooting a BEAST Tree

The best way to root a tree with BEAST is to do it when you are first generating the BEAST file. Remake the BEAST file, but let's add an outgroup this time. Set up the file as we did the first time. Then click Priors, then click Add prior, and move all the taxa to the right side, except Conus loroisii and Nautilus pompilius. These taxa will from a monophyletic outgroup. C. loroisii and N. pompilius are members of Gastropoda and Cephalopoda, respectively. Click OK and save the file as normal. Run BEAST as we did earler. 

Let's import the new tree and graph it. We will add extra information on the tree, such as if a species is gonochoristic/hermaphroditic, exhibits DUI/No DUI, or is from a particular clade. To identify node numbers, add geom_text(aes(label=node))

````{r}
cox1_beast_root <- read.beast('cox1_beast_root.tre')

c.names <- read.csv(file = "names.csv", header=FALSE) #import an csv file of the original tip labs and what we want to rename them as
cox1_beast_root <- rename_taxa(cox1_beast_root, c.names) #rename the taxa
bvData<-read.csv("bvData.csv")

ggtree(cox1_beast_root) %<+% bvData + xlim(0, 4) +
  geom_tiplab(align = TRUE) + 
  geom_cladelab(node=38, label="Heterodonta", align=TRUE,  
                offset = 1.7) +
  geom_cladelab(node=43, label="Paleoheterodonta", align=TRUE,  
                offset = 1.7) +
  geom_cladelab(node=32, label="Pteriomorphia", align=TRUE,  
                offset = 1.7) +
  geom_cladelab(node=26, label="Outgroup", align=TRUE,  
                offset = 1.7) +
  geom_tippoint(aes(color = DUI, shape = mode)) +
  geom_text2(aes(label=round(as.numeric(posterior), 2), 
                 subset=as.numeric(posterior)> 0.9, 
                 x=branch), hjust = 0.75, vjust=0) 
````

That covers the basics of making and graphing trees. Congrats! To test yourself, change any of the inputs in the ggtree object, or even try making a tree of your own using different sequences, such as 16S rRNA or even a gene tree. 

## Ancestral State Reconstruction and Correlation of Discrete Characters

An important step of understanding a discrete character in a taxonomic group is determining when the trait evolved. Furthermore, many discrete characters are correlated with other, possibly related traits. In this particular case in bivalves, we want to know if gonochorism and no DUI are ancestral states of bivalves.

# Ancestral State Reconstruction
We will use ancestral state reconstruction of gonochorism/hermaphroditism and DUI/No DUI using the phytools package by Liam Revell. We will do this using the rooted BEAST tree we made earlier. First we will evaluate if gonochorism or hermaphroditism is the ancestral state of bivalves.

````{r}
sex_modes <- as.factor(setNames(bvData$mode, bvData$Bivalve))

bivalve.trees<-make.simmap(drop.tip(cox1_beast_root@phylo,setdiff(cox1_beast_root@phylo$tip.label,names(sex_modes))),sex_modes,model="SYM",nsim=100)
obj <- summary(bivalve.trees, plot = FALSE)
cols<-setNames(palette()[1:2],levels(sex_modes))
plot(obj,colors=cols,fsize=0.8,cex=c(0.5,0.3))
add.simmap.legend(colors=cols, prompt = FALSE, y=2)
````

Now, we will do the same for DUI.

````{r}
DUI_modes <- as.factor(setNames(bvData$DUI, bvData$Bivalve))

bivalve.trees<-make.simmap(drop.tip(cox1_beast_root@phylo,setdiff(cox1_beast_root@phylo$tip.label,names(DUI_modes))),DUI_modes,model="SYM",nsim=100)
obj <- summary(bivalve.trees, plot = FALSE)
cols<-setNames(palette()[1:2],levels(DUI_modes))
plot(obj,colors=cols,fsize=0.8,cex=c(0.5,0.3))
add.simmap.legend(colors=cols, prompt = FALSE, y = 2)
````

Based on these two figures, we can conclude that the ancestral bivalve was gonochoristic and likely did not exhibit DUI. Based on stochastic mapping of DUI, this phenomenon likely evolved three separate times in bivalves, once in each bivalve subclass.

# Correlation of Discrete Traits

````{r}
par(mfrow=c(1,2))
plot(force.ultrametric(cox1_beast_root@phylo),show.tip.label=FALSE,no.margin=TRUE)
par(fg="transparent")
tiplabels(pie=to.matrix(sex_modes[cox1_beast_root@phylo$tip.label],c("Gonochoristic","Hermaphroditic")),piecol=c("red","blue"),cex=0.3)
par(fg="black")
add.simmap.legend(colors=setNames(c("red","blue"),c("Gonochoristic","Hermaphroditic")),prompt=FALSE, x=0.1,y=7,fsize=1)
plot(force.ultrametric(cox1_beast_root@phylo),show.tip.label=FALSE,no.margin=TRUE,direction="leftwards")
tiplabels(pie=to.matrix(DUI_modes[cox1_beast_root@phylo$tip.label],c("DUI","No DUI")),piecol=c("brown","cyan"),cex=0.3)
add.simmap.legend(colors=setNames(c("brown","cyan"),c("DUI","No DUI")),prompt=FALSE, x=0.7,y=7,fsize=1)

````

Here, we want to match up the colors. Are red circles (gonochorism) matched up with brown circles (DUI)? Are blue circles (hermaphroditism) matched up with cyan circles (No DUI)?

Now, we use a model to determine if sex mode depends on DUI mode and vice versa. 

````{r}
fit.sd <- fitPagel(cox1_beast_root@phylo, sex_modes, DUI_modes)
fit.sd
````

Based on these results, we cannot conclude that sex_mode and DUI_mode are correlated because the p value is greater than 0.05. However, there is some evidence to support that gonochorism and DUI are correlated as the p value is approximately 0.1. How would the results change if the RAxML tree was used, or if a completely new/larger tree was used? It is important to note that every bivalve species that exhibits DUI is a gonochoristic species, except Semimytilus algosus, which is hermaphroditic. 
